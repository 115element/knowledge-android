##①书写Java代码
```java
public class JniTest {
    static {
        System.loadLibrary("hello");  //载入本地库[这个是我们开发之后生成的库文件名]
    }

    public static native void getString();  //所有native关键词修饰的都是对本地的声明
}
```
/*
 * 声明 native方法：如果你想将一个方法做为一个本地 方法的话，那么你就必须声明该方法为native的，并且不能实现。
 * 其中方法的参数和返回值在后面讲述。 Load动态库：System.loadLibrary("hello");
 * 同时需要注意的是System.loadLibrary();的参数“hello”是动态库的名字。
 * [如果自己开发，那么也是我们开发后的动态库名字]
 * [如果别人开发，那么就是别人已经开发好的动态库名字]
 */


##②生成 com_example_knowledge_android_jnistudy_JniTest.h 头文件  
```text
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_example_knowledge_android_jnistudy_JniTest */

#ifndef _Included_com_example_knowledge_android_jnistudy_JniTest
#define _Included_com_example_knowledge_android_jnistudy_JniTest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_example_knowledge_android_jnistudy_JniTest
 * Method:    getString
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_knowledge_1android_jnistudy_JniTest_getString
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```
JNI函数名称分为三部分：首先是Java关键字，供Java虚拟机识别；然后是调用者类名称(全限定的类名，其中用下划线代替名称分隔符)；最后是对应的方法名称，各段名称之间用下划线分割。
JNI函数的参数也由三部分组成：首先是JNIEnv *,是一个指向JNI运行环境的指针；第二个参数随本地方法是静态还是非静态而有所不同一一非静态本地方法的第二个参数是对对象的引用，而静态本地方法的第二个参数是对其Java类的引用；其余的参数对应通常Java方法的参数，参数类型需要根据一定规则进行映射。
编写C++文件com_example_knowledge_android_jnistudy_JniTest.h的实现类，我是比较常用VC6.0来生成dll文件（hello.dll）的
[这里我们可以这样理解：这个h文件相当于我们在java里面的接口，这里声明了一个Java_com_example_knowledge_1android_jnistudy_JniTest_getString(JNIEnv *, jobject);方法。
然后在我们的本地方法里面实现这个方法，也就是说我们在编写 C/C++程序的时候所使用的方法名必须和这里的一致]。

##③编写本地代码实现
4)编写本地方法实现和由javah命令生成的头文件里面声明的方法名相同的方法。

代码2：
```text
#include <jni.h>
#include <com_example_knowledge_android_jnistudy_JniTest.h>
//#includeotherheaders

JNIEXPORT  void  JNICALL
Java_com_example_knowledge_1android_jnistudy_JniTest_getString(JNIEnv * env,jobject obj)
{
    printf ( "HelloWorld!\n" );
    return ;
}
```
注意代码2中的第1行，需要将jni.h（该文件可以在%JAVA_HOME%/include文件夹下面找到）文件引入，因为在程序中的JNIEnv、 jobject等类型都是在该头文件中定义的；
另外在第2行需要将com_example_knowledge_android_jnistudy_JniTest.h头文件引入
（我是这么理解的：相当于我们在编写java程序的时候，实现一个 接口的话需要声明才可以，这里就是将com_example_knowledge_android_jnistudy_JniTest.h头文件里面声明的方法加以实现。当然不一定是这样）。
然后保存为 com_example_knowledge_android_jnistudy_JniTestImpl.c 就ok了。

##④生成动态库
5) 生成动态库
这里以在Windows中为例，需要生成dll文件。在保存HelloWorldImpl.c文件夹下面，使用 VC的 编译器cl成。 
   cl -I%java_home%\include -I%java_home%\include\win32 -LD com_example_knowledge_android_jnistudy_JniTestImpl.c -Fe hello.dll 
   注意：生成的dll文件名在选项-Fe后面配置，这里是hello，因为在JniTest.java文件中我们loadLibrary的时候使用的名字是hello。
   当然这里修改之后那里也需要修改。另外需要将-I%java_home%\include -I%java_home%\include\win32参数加上，因为在第四步里面编写本地方法的时候引入了jni.h文件。
如果配置了MinGW,也可以这样来编译：
   gcc -Wall -D_JNI_IMPLEMENTATION_ -Wl,--kill-at -Id:/java/include –Id:/java/include/win32 -shared -o (输出的dll文件名，如sum.dll) (输入的c/c++源文件,如abc.c)。

##⑤运行程序
6) 运行程序
   打印HelloWorld就ok.
如果用eclipse，需将dll或so文件放在项目下，而不是src及其子目录下。
如果用命令行编译，把dll文件放在该包的同目录下。 

